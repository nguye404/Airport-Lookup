/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "airport.h"
#include "kdTree.h"
#include "errno.h"
using namespace std;

static int create = 0;
struct kd_node_t *root;

/*
 Create kd tree for the 1072 airports, open the file and parse through it
 Parse through the lines to airport code, latitude, longitude, airport name
 */
void createTree()
{
	// There are 1072 airports in airport-locations.txt
    struct kd_node_t wp[1072];  
	
	ifstream file;
	
	// Open the file
	file.open("airport-locations.txt");

	if (file.is_open())
	{
		string line;
		getline(file, line);
		int index = 0;
		
		// read the file and store airport information to the array of kd_node_t 
		while(getline(file, line))
		{
			if (line != "")
			{
				string airportCode, airportName;
				double latitude, longitude;
                /*
                 get the airport code
                 */
				airportCode = line.substr(1, 3);
                /*
                 get the latitude of the airport
                 */
				char* latTemp = strdup(line.substr(6, 5).c_str());
				latitude = atof(latTemp);
                /*
                 get the longitude of the airport
                 */
				char* longTemp = strdup(line.substr(12, 7).c_str());
				longitude = atof(longTemp);

				int size = line.size();
                /*
                 get the airport name
                 */
				airportName = line.substr(20, size - 20);

				// get rid of the space before the airportName
				int airportName_size = airportName.size();
				int startIndex;
				for (int i = 0; i < airportName_size; i++)
				{
					if (!isspace(airportName[i]))
					{
						startIndex = i;
						break;
					}
				}

				if(startIndex != 0)
				{
					airportName = airportName.substr(startIndex, airportName_size-1);
				}
                /*
                put the values into the kd tree
                */
				wp[index].gps[0] = latitude;
				wp[index].gps[1] = longitude;
				wp[index].airportCode = airportCode;
				wp[index].airportName = airportName;

				index++;
			}
		}
	}
	// Close the file
	file.close();

	root = make_tree(wp, sizeof(wp) / sizeof(wp[1]), 0, 3);
}

nearestAiports_ret *
findairport_1_svc(cityNode *argp, struct svc_req *rqstp)
{
	static nearestAiports_ret result;
	
	// only create the KD tree once
	if(create++ == 0) 
	{
		createTree();
	}
    /*
     vector to hold first nearest airport
     */
	vector<airportNode> vFiveNearest;
	vFiveNearest.clear();
    /*
     call function to receive five nearest airports with function
     */
	vFiveNearest = fiveNearestAirports(root, argp->cityLat, argp->cityLong);

	airportNode  **temp;
	
	// Free previous result
	xdr_free((xdrproc_t)xdr_nearestAiports_ret, (char*)(&result));
	
	temp = &result.nearestAiports_ret_u.list;
    /*
     finds the nearest 5 airports
     makes a new airport node, gets name, code, latitude, longitude, and distance
     */
	for (int i = 0; i < 5; i++)
	{
		(*temp) = new airportNode;
		(*temp)->airportName = new char[MAXLEN];
		(*temp)->airportName = vFiveNearest[i].airportName;
		(*temp)->airportCode = new char[MAXLEN];
		(*temp)->airportCode = vFiveNearest[i].airportCode;
		(*temp)->latitude = vFiveNearest[i].latitude;
		(*temp)->longitude = vFiveNearest[i].longitude;
		(*temp)->distance = vFiveNearest[i].distance;
		
		temp = &(*temp)->next;
		(*temp) = NULL;	
	}
	
	// no error
	result.err = 0;
	 
	return &result;
}
